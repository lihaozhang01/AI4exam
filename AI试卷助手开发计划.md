### **AI智能试卷生成与辅导系统 - 项目开发方案**

#### 1\. 项目概述 (Project Overview)

**项目名称**: AI智能试卷生成与辅导系统 (AI-Powered Test & Tutoring System)

**项目愿景**: 开发一个高度互动的在线学习工具，允许用户通过提供自己的学习材料（文档或文本），动态生成定制化的练习题，并通过与AI的对话式交互，获得深度的、个性化的学习反馈。

**核心价值**:

- 个性化出题: 将任何静态的学习资料转化为动态的、可测验的试卷。

- 智能辅导: 超越简单的对错判断，提供具有启发性的、上下文感知的AI反馈与讨论。

- 高效学习: 通过“生成 -> 作答 -> 反馈 -> 讨论”的闭环，加速知识的内化过程。

- 学习资产沉淀: 用户的所有试卷、作答记录和AI反馈都将被持久化保存，构建起个人专属的、可追溯的知识库。

- 长期追踪与复习: 支持用户随时回顾历史试卷，进行重做或针对性复习。

**目标用户**: 学生、教师、企业培训师、以及任何有自主学习需求的个人。


#### 2\. 核心功能模块 (Core Feature Breakdown)

1.  **内容输入模块**:
      * 支持用户直接粘贴大段文本。
      * 支持用户上传文档（初期支持 .txt, 后续扩展至 .pdf, .docx）。
2.  **试卷生成配置模块**:
      * 允许用户选择生成的题目类型（选择题、填空题、论述题、混合）。
      * 允许用户配置题目数量和难度。
3.  **试卷生命周期管理模块**:
	 - 动态渲染AI生成的试卷。
	- 试卷与作答记录的持久化保存：生成、作答、批改的每一步都与用户账户关联并存入数据库。
	- 历史试卷仪表盘: 提供一个中心页面，展示用户所有的历史试卷列表。
	- 历史试卷查阅与重做: 用户可以随时打开过去创建的试卷进行查看或重新作答。
4.  **AI智能反馈与讨论模块**:
      * 提交论述题给AI进行批改，并展示结构化的反馈。
      * 提供“与AI讨论”的聊天式界面，支持上下文联动的多轮对话。
5.  **用户配置模块**:  
	- 支持用户通过用户名和密码进行注册。
	- 支持用户登录以访问其个人数据。
	- 使用JWT (JSON Web Tokens) 进行安全的会话管理。


#### 3\. 技术架构设计 (Technical Architecture)

这是一个经典的前后端分离架构：

```mermaid
graph TD
    subgraph 用户设备 (PC/Mac/Phone)
        A[浏览器 - React应用]
    end

    subgraph 互联网 (HTTPS)
        B(API 请求/响应)
    end

    subgraph 云服务器
        subgraph 后端服务 (FastAPI)
            C[API 接口层]
            D[文档处理模块]
            E[Prompt构造与AI通信模块]
            F(API Key 安全存储)
        end
    end

    subgraph 第三方服务
        G[AI模型服务 (Google Gemini API)]
    end

    A -- JSON/文件上传 --> B
    B -- 传递请求 --> C
    C -- 调用 --> D
    D -- 提取文本 --> E
    E -- 构造Prompt,携带Key --> G
    G -- 返回AI结果 --> E
    E -- 格式化为JSON --> C
    C -- 封装响应 --> B
    B -- 返回JSON --> A
```

#### 4\. 详细技术选型 (Detailed Tech Stack)

  * **前端 (Frontend)**

      * **核心框架**: `React 18+`
      * **构建工具**: `Vite` (提供极速的开发服务器和高效的打包)
      * **UI组件库**: `Ant Design` (提供成熟的上传、表单、卡片、列表等组件，非常适合本项目)
      * **状态管理**: `Zustand` 或 `Redux Toolkit` (Zustand更轻量，上手快，足够本项目使用)
      * **路由管理**: `react-router-dom`
      * **API请求**: `Axios` (提供更方便的请求配置和错误处理)

  * **后端 (Backend)**

      * **核心框架**: `FastAPI`
      * **运行环境**: `Python 3.9+`
      * **ASGI服务器**: `Uvicorn`
      * **数据校验**: `Pydantic` (FastAPI内置，极度好用)
      * **AI SDK**: `google-generativeai`
      * **文档解析**: `pypdf` (用于PDF), `python-docx` (用于Word文档)
ORM (对象关系映射): SQLAlchemy (配合 asyncpg 实现异步数据库操作)。我们将使用声明式模型，将Python类直接映射到数据库表。

数据库迁移工具: Alembic。用于管理数据库表结构的变更，每次修改模型后，可通过它生成和应用迁移脚本。

认证库: passlib (用于密码的哈希加密与验证), python-jose (用于创建和解析JWT)。
这是我们数据持久化的核心，初步设计如下几个核心模型（表）：

User (用户表): `id, username, hashed_password, created_at

TestSession (试卷会话表): `id, user_id (外键), title (可由用户命名或AI生成), source_material (源文本), config_json (生成配置), created_at

Question (题目表): `id, test_session_id (外键), question_data (包含题干、选项的JSON), answer_data (包含答案、解析的JSON)

UserAnswer (用户作答表): `id, question_id (外键), user_id (外键), answer_content (用户答案的JSON), evaluation_result (AI批改结果的JSON), submitted_at
#### 5\. 分阶段开发路线图 (Development Roadmap)

**第一阶段：MVP - 核心流程验证 (预计2-3周)**

- **后端**:

	- 搭建FastAPI项目，集成SQLAlchemy和Alembic。
	- 定义所有数据库模型，并完成首次数据库迁移。
	- 实现完整的用户注册和登录接口 (/auth)。
	- 实现 /api/tests (POST) 接口，能生成试卷并将结果存入数据库。

- **前端**:

	- 搭建React项目。
	- 创建注册页、登录页，并实现完整的认证流程 (存储和发送JWT)。
	- 创建主仪表盘页面，用于展示历史试卷列表。
	- 实现试卷创建流程，并能调用新的API。
目标: 用户可以注册登录，创建试卷，并在自己的账户下看到保存的试卷记录。

第二阶段：完成交互闭环 (预计2-3周)

- **后端**: 实现 /api/tests/{test_id}/submit 和 /api/questions/{question_id}/discuss 接口。

- **前端**:

	- 实现从仪表盘点击进入历史试卷详情页。
	- 完成作答、即时批改、论述题提交批改的完整交互。
	- 构建“与AI讨论”的聊天界面。

**目标**: 用户可以在一个已保存的试卷上，完成“作答-反馈-讨论”的完整学习闭环。

**第三阶段：高级功能与优化 (预计2周)**

  * **后端**:
      * 实现文件上传接口，并集成 `pypdf` 等库来处理文档。
  * **前端**:
      * 使用Ant Design的`Upload`组件实现文件上传功能。
      * 实现用户API Key的本地存储和读取 (`localStorage`)。
      * 优化UI/UX，增加加载动画和错误提示。
  * **目标**: 成为一个功能完整、体验良好的工具。

**第四阶段：部署与发布**

  * **后端**: 将FastAPI应用容器化（使用Dockerfile），并部署到Render或Railway等云平台。
  * **前端**: 将React应用部署到Vercel平台。
  * 进行端到端测试，收集用户反馈。

### **AI智能试卷系统 - 详细交互逻辑方案**

#### **阶段一：首次访问与环境配置**

**用户目标**: 完成初次使用的必要设置，让工具准备就绪。

1.  **场景：用户首次打开网页**
    * **系统行为**: 页面加载后，系统立即检查浏览器的 `localStorage` 中是否存在 `apiKey`。
    * **界面呈现 (无Key)**:
        * 如果 `apiKey` 不存在，页面中心会弹出一个**模态对话框 (Modal)**，友好地欢迎用户。
        * 此对话框是**强制性的**，用户无法操作后方的灰色主界面。
        * 对话框内包含：
            * 一个清晰的标题：“欢迎使用AI智能试卷助手”。
            * 一段说明文字：“为了使用AI的强大功能，请输入您的API Key。”
            * 一个输入框，用于粘贴API Key。
            * 一个“保存”按钮。
            * 一个可点击的帮助链接：“如何获取我的API Key？”
    * **界面呈现 (有Key)**: 如果 `localStorage` 中已存在 `apiKey`，则不弹出任何对话框，直接进入**阶段二**的主界面。

2.  **场景：用户保存API Key**
    * **用户操作**: 在对话框的输入框中粘贴自己的API Key，然后点击“保存”按钮。
    * **系统行为**:
        * 前端对Key的格式进行一个极简的检查（例如，不能为空）。
        * 点击“保存”后，系统将Key存入 `localStorage`。
        * **界面反馈**:
            * 对话框平滑地淡出或关闭。
            * 主界面变为可用状态。
            * 页面右上角弹出一个短暂的成功提示：“配置成功，您现在可以开始使用了！”（3秒后自动消失）。
            * 在页面的某个角落（如右上角），会出现一个“设置” (小齿轮图标) 按钮，允许用户日后修改Key。

#### **阶段二：创建试卷 - 提供知识源与设定要求**

**用户目标**: 输入学习材料，并清晰地告诉AI自己想要的试卷是什么样的。

1.  **场景：用户准备输入内容**
    * **界面布局**: 主界面清晰地划分为两个区域：
        * **区域一：“提供知识源”**，此区域使用标签页 (Tabs) 设计，包含“粘贴文本”和“上传文档”两个选项，默认为“粘贴文本”。
        * **区域二：“设定出题要求”**。

2.  **场景：用户输入知识源 (二选一)**
    * **路径A：粘贴文本**
        * **用户操作**: 用户将准备好的学习资料文字粘贴到一个大的文本区域 (`<textarea>`) 中。
        * **界面反馈**: 文本框下方可以实时显示字数统计，让用户对内容量有概念。
    * **路径B：上传文档**
        * **用户操作**: 点击“上传文档”标签页，文本框切换为一个文件上传组件 (例如Ant Design的`Upload`组件)。用户点击或拖拽文件到此区域。
        * **界面反馈**:
            * 前端会进行**客户端文件类型校验**，如果用户上传了不支持的格式（如.jpg），会立即提示“格式不支持，请上传.txt, .pdf, .docx等文档”。
            * 上传成功后，组件区域会显示文件名和一个成功的图标，表示“文件已就绪”。

3.  **场景：用户设定出题要求**
    * **用户操作**: 在“设定出题要求”区域，用户进行点选和配置：
        * **题型组合**: 通过多选框 (Checkboxes) 选择“选择题”、“填空题”、“论述题”。
        * **题目数量**: 通过滑块 (Slider) 或数字输入框来设定期望的题目总数。
        * **难度等级**: 通过单选按钮组 (Radio Group) 选择“简单”、“中等”或“困难”。
    * **界面联动**:
        * 页面底部的“**生成试卷**”按钮，默认是**灰色不可用**状态。
        * **必须同时满足**以下两个条件，该按钮才会被激活并变为高亮颜色：
            1.  “提供知识源”区域已有内容（文本框非空或文件已上传）。
            2.  “设定出题要求”区域至少选择了一种题型。
        * 这可以有效防止用户发起无效的请求。

#### **阶段三：生成试卷与智能反馈**

**用户目标**: 触发AI工作，并以清晰、友好的方式接收生成的试卷。

1.  **场景：用户点击“生成试卷”**
    * **用户操作**: 点击已激活的“生成试卷”按钮。
    * **界面反馈 (这是提升体验的关键)**:
        * 整个**阶段二**的配置界面整体变为**禁用状态**（例如，覆盖一层半透明的遮罩），防止用户在生成过程中修改参数。
        * “生成试卷”按钮的文字变为“AI正在全力出题中...”，并带有一个旋转的加载图标。
        * 页面下方，原先空白的试卷区域出现一个**加载动画和状态提示**，文字可以动态变化，以缓解用户的等待焦虑，例如：
            * “正在阅读和理解您提供的材料...”
            * “已定位核心知识点，开始设计题目...”
            * “正在进行最后润色，马上就好！”
    * **系统行为**: 前端将所有配置和知识源文本打包，异步调用后端的 `POST /api/generate-test` 接口。

2.  **场景：试卷生成完毕**
    * **系统行为**: 前端成功接收到后端返回的试卷JSON数据。
    * **界面反馈**:
        * 加载动画和状态提示消失。
        * 页面以**平滑的动画效果**（如淡入和向下展开）渲染出完整的试卷。
        * 页面自动滚动到试卷的开头。
        * 试卷中的每一道题都是一个独立的“卡片”，结构清晰。

#### **阶段四：答题、批改与深度讨论**

**用户目标**: 完成作答，获取即时、准确的反馈，并对疑难点进行深入探究。

1.  **场景：用户作答**
    * **用户操作**: 用户在试卷上依次填写答案。选择题点选选项，填空和论述题在输入框中输入文字。
    * **界面反馈**: 页面底部有一个醒目的“**完成批改**”按钮。

2.  **场景：用户提交批改**
    * **用户操作**: 点击“完成批改”按钮。
    * **界面反馈 (即时部分)**:
        * 所有题目的输入框和选项都变为**只读状态**。
        * **瞬间发生**：所有**选择题**和**填空题**的卡片上会立即出现批改结果。
            * 正确答案的题目卡片边缘或标题变为**绿色**，并显示一个 ✔️ 图标。
            * 错误答案的题目卡片边缘或标题变为**红色**，并显示一个 ✖️ 图标，同时**在其下方直接展示出正确答案和简要解析**（这份解析在生成试卷时已一并获取）。
    * **界面反馈 (等待AI部分)**:
        * 所有**论述题**的卡片内，会出现一个局部的加载动画，提示“AI导师正在批阅您的论述题...”。
    * **系统行为**: 前端将所有论述题的答案打包，调用后端的 `POST /api/evaluate-essay` 接口。

3.  **场景：接收论述题批改结果**
    * **系统行为**: 后端返回论述题的批改JSON。
    * **界面反馈**: 对应论述题卡片内的加载动画消失，取而代之的是一个**结构化的反馈报告**，包含：
        * **评分** (例如，85/100)。
        * **总体评语** (HTML格式，关键词已加粗)。
        * **知识点命中清单** (一个带对勾和叉的列表)。
        * **改进建议**。

4.  **场景：用户发起深度讨论**
    * **用户操作**: 在任意一道（尤其是答错的）题目卡片上，用户会发现多了一个“**与AI深入讨论**”的按钮。用户点击此按钮。
    * **界面反馈**:
        * 一个**聊天窗口**（可以是侧边栏或模态框）滑出或淡入。
        * 窗口的标题清晰地标明了正在讨论的是哪道题。
        * 窗口内已预置了第一条信息，例如AI说：“好的，我们来深入聊聊这道题。你对于[知识点X]有什么疑问吗？”
        * 底部是一个聊天输入框和发送按钮。
    * **用户操作**: 用户输入问题（例如“为什么答案是A而不是B？”）并发送。
    * **界面反馈**:
        * 用户的消息出现在聊天窗口右侧。
        * 左侧出现“对方正在输入...”的提示。
    * **系统行为**: 前端调用 `POST /api/discuss` 接口，**务必将当前题目的ID和完整的聊天历史一并发送**，以保证AI理解上下文。
    * **界面反馈**: AI的回答出现在聊天窗口左侧。这个对话可以持续进行，直到用户关闭聊天窗口，返回试卷界面。


好的，非常棒。一个好的项目方案需要一个同样出色的开发流程来支撑。对于一个2到3人的小团队，我们的核心应该是**敏捷、高效、沟通顺畅**，避免不必要的流程和会议。

下面，我为您规划一个专门针对这个项目、基于敏捷思想的开发流程。

---

### **AI智能试卷系统 - 团队开发流程 (2-3人)**

#### 1. 角色与职责分工 (Roles & Responsibilities)

明确的分工是高效协作的基础，即使在小团队中也是如此。

* **如果团队为2人:**
    * **开发者A (主导前端 - React)**:
        * 负责所有前端界面的开发、组件化、状态管理和用户交互逻辑。
        * 负责前端项目的构建、打包和部署。
        * **与开发者B共同设计和敲定API接口**。
    * **开发者B (主导后端 - FastAPI)**:
        * 负责所有后端API的开发、数据库设计与管理、AI集成和Prompt工程。
        * 负责后端服务的部署、数据库维护和服务器运维。
        * **与开发者A共同设计和敲定API接口**。

* **如果团队为3人 (推荐分工):**
    * **开发者A (前端专家)**: 职责同上，可以更专注于前端的性能优化和复杂交互实现。
    * **开发者B (后端专家)**: 职责同上，可以更专注于后端的性能、安全和AI模型的调优。
    * **开发者C (全栈/项目协调/DevOps)**:
        * **作为“粘合剂”**: 负责搭建和维护开发、部署环境（CI/CD流水线），是团队的DevOps工程师。
        * **作为“协调者”**: 负责管理项目看板，跟进任务进度，组织必要的讨论，是团队的项目经理(PM)。
        * **作为“摇摆人”**: 具备全栈能力，可以在前端或后端需要支援时随时补位。

#### 2. 协作工具栈 (Collaboration Tool Stack)

* **代码托管与项目管理**: **GitHub** (或 GitLab)
    * **Repositories**: 分别为前端和后端创建两个代码仓库。
    * **Issues**: 将开发计划书中的每个功能点或任务，创建为一个Issue。这是我们的**任务待办清单 (Backlog)**。
    * **Projects**: 开启Projects功能，创建一个**看板 (Kanban Board)**，包含列：`待办 (To Do)`、`进行中 (In Progress)`、`待审查 (In Review)`、`完成 (Done)`。所有Issues都在这个看板上进行可视化管理。
* **即时通讯**: **Slack / Discord / 飞书(Lark)**
    * 创建一个项目专属频道，用于日常的快速沟通、问题讨论和通知同步。
* **文档与知识库**: **Notion** (或使用GitHub的Wiki)
    * 用于存放本开发方案、API接口文档、会议纪要和技术调研等沉淀下来的知识。

#### 3. 敏捷开发工作流 (Agile Development Workflow)

我们采用以**周**为单位的**迭代周期 (Sprints)**。

**一个完整的迭代周期 (1-2周) 如下：**

**第一步：周一上午 · 迭代规划会 (Sprint Planning)**
* **时长**: 1小时内。
* **内容**:
    1.  全员一起审视GitHub Projects上的“待办”列表。
    2.  根据我们制定的开发路线图，**共同决定**本周要完成的最重要的2-4个功能点（Issues）。
    3.  将选定的Issues从“待办”拖入“进行中”。
    4.  **【至关重要】** 对于需要前后端协作的功能，在会上**立即讨论并敲定API接口的设计**（URL、请求方法、请求体、响应体），并由后端负责人记录到文档中。这是本周的“契约”。

**第二步：周一至周五 · 并行开发与每日站会**
* **并行开发**:
    * 前端和后端负责人根据已经定义好的API“契约”，各自在自己的代码库中开发功能。
    * **Git分支模型**:
        1.  从`main`主分支创建新的**功能分支**，命名清晰，如 `feature/user-login` 或 `backend/generate-test-api`。
        2.  在自己的功能分支上进行开发和提交。
* **每日站会 (Daily Stand-up)**:
    * **时间**: 每天早上开始工作时的前15分钟。
    * **内容**: 每人快速回答三个问题：
        1.  我昨天做了什么？
        2.  我今天计划做什么？
        3.  我遇到了什么困难或阻碍？
    * **目的**: 快速同步进度，暴露问题，寻求帮助，保持团队节奏。

**第三步：开发完成 · 代码审查 (Code Review)**
* **触发**: 当一个功能分支开发完毕后，开发者在GitHub上创建一个**Pull Request (PR)**，请求合并到`main`分支。
* **指定审查者**: PR中必须 `@` 另一位（或两位）同事进行代码审查。
* **审查内容**: 审查者检查代码的逻辑、风格、健壮性和是否符合团队规范。在PR下方进行评论和讨论。
* **自动化检查 (CI)**: (由开发者C配置) PR一旦创建，会自动触发GitHub Actions，运行**代码风格检查 (Linting)** 和 **单元测试**。如果检查不通过，PR将被禁止合并。
* **合并**: 只有当**所有自动化检查通过**并且**至少一位同事点击“Approve”**后，该PR才能被合并到`main`分支。

**第四步：持续集成与部署 (CI/CD)**
* **触发**: 当PR成功合并到`main`分支后。
* **自动化部署 (CD)**: (由开发者C配置)
    * **后端**: GitHub Actions会自动构建Docker镜像，并将其推送到Render等云平台，完成后端服务的**自动更新**。
    * **前端**: GitHub Actions会自动执行构建命令，并将静态文件部署到Vercel平台，完成前端网站的**自动更新**。
* **环境**: 建议至少有一个**预演环境 (Staging)**，用于在正式发布前进行内部测试。合并到`develop`分支触发部署到预演环境，合并到`main`分支触发部署到生产环境。

**第五步：周五下午 · 迭代评审与回顾 (Sprint Review & Retrospective)**
* **时长**: 1小时内。
* **内容**:
    1.  **评审 (Review)**: 团队成员轮流在**预演环境**上演示本周完成的新功能。
    2.  **回顾 (Retrospective)**: 合上电脑，全员讨论：
        * 本周的工作哪些地方做得很好？
        * 我们遇到了哪些问题？流程上有什么可以改进的地方？
        * 下一周我们可以尝试做些什么来提高效率或质量？
* **目的**: 庆祝成果，并持续优化我们的协作流程本身。
